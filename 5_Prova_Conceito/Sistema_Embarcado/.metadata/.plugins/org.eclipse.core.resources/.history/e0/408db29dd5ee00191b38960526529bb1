//Altera√I2C_RECVß√£o para vers√£o 1...
/*

#include "stdint.h"
#include "mpu6050.h"

uint8_t mpu6050_init(){
	uint8_t temporario = 1;
	return temporario;
}
*/

/*
†* mpu6050.c
†*
†* Created on: Jan 14, 2015
†* Author: lab
†*/
#include "mpu6050.h"
#include "myiic_g.h"
#include "myiic_m.h"
#include "hal_iic.h"
#include "MKL25Z4.h"
#include "function.h"
#include <math.h>
#include <stdio.h>
#include "delay.h"
#include "PE_Types.h"

#define I2C_ADDR_MPU6050 (0x68<<1)
#define I2C0_B I2C0_BASE_PTR

/*
††††This delay is very important, it may cause w-r operation failure.
††††The delay time is dependent on the current baudrate.
††††It must be equal or longer than at least on clock of current baudrate.
††††So, if you set to a higher baudrate, the loop value can be reduced from 4000 to 20, depending on your current baudrate.
*/
Static void pause(void)
{
††††Int n;
††††// Source program is n < 4000
††††For(n=0; n<2000; n++)
††††††††Asm("nop");
}

Uint8 hal_dev_mpu6050_read_reg(uint8 addr)
{
Uint8 result;

††††I2c_start(I2C0_B);

††††I2c_write_byte(I2C0_B, I2C_ADDR_MPU6050 | I2C_WRITE);
††††I2c_wait(I2C0_B);
††††I2c_get_ack(I2C0_B);

††††I2c_write_byte(I2C0_B, addr);
††††I2c_wait(I2C0_B);
††††I2c_get_ack(I2C0_B);

††††I2c_repeated_start(I2C0_B);
††††I2c_write_byte(I2C0_B, I2C_ADDR_MPU6050 | I2C_READ);
††††I2c_wait(I2C0_B);
††††I2c_get_ack(I2C0_B);

††††I2c_set_rx_mode(I2C0_B);

††††I2c_give_nack(I2C0_B);
††††Result = i2c_read_byte(I2C0_B);
††††I2c_wait(I2C0_B);

††††I2c_stop(I2C0_B);
††††Result = i2c_read_byte(I2C0_B);
††††Pause();
††††Return result;
}
Void hal_dev_mpu6050_write_reg(uint8 addr, uint8 data)
{
††††I2c_start(I2C0_B);

††††I2c_write_byte(I2C0_B, I2C_ADDR_MPU6050|I2C_WRITE);
††††I2c_wait(I2C0_B);
††††I2c_get_ack(I2C0_B);

††††I2c_write_byte(I2C0_B, addr);
††††I2c_wait(I2C0_B);
††††I2c_get_ack(I2C0_B);

††††I2c_write_byte(I2C0_B, data);
††††I2c_wait(I2C0_B);
††††I2c_get_ack(I2C0_B);

††††I2c_stop(I2C0_B);
††††Pause();
}


Void MPU6050_Init(void)
{
Uint8 d;

d=0x00; // release sleep
Hal_dev_mpu6050_write_reg(PWR_MGMT_1,d);

d=0x13; // sampling frequency: 1000hz, the frequency is 20
Hal_dev_mpu6050_write_reg(SMPLRT_DIV,d);
d = hal_dev_mpu6050_read_reg(SMPLRT_DIV);

d=0x01; // filter 184HZ
Hal_dev_mpu6050_write_reg(CONFIG,d);

d=0x18; // range
Hal_dev_mpu6050_write_reg(GYRO_CONFIG,d);

d=0x01;//range
Hal_dev_mpu6050_write_reg(ACCEL_CONFIG,d);

d=0x30; // interrupt signal configuration
Hal_dev_mpu6050_write_reg(INT_CONFIGURATION,d);

d=0x01; // interrupt enable
Hal_dev_mpu6050_write_reg(INTERRUPT_ENABLE,d);

//time_delay_us(10000);

}

Void get_gyro(short *Gx,short *Gy,short *Gz)
{
Uint8 reg[6],status;

††††Reg[0] = hal_dev_mpu6050_read_reg(GYRO_XOUT_H);
††††Reg[1] = hal_dev_mpu6050_read_reg(GYRO_XOUT_L);

††††Reg[2] = hal_dev_mpu6050_read_reg(GYRO_YOUT_H);
††††Reg[3] = hal_dev_mpu6050_read_reg(GYRO_YOUT_L);

††††Reg[4] = hal_dev_mpu6050_read_reg(GYRO_ZOUT_H);
††††Reg[5] = hal_dev_mpu6050_read_reg(GYRO_ZOUT_L);
††††††††††††
††††*Gx = ( (short) (reg[0] << 8) + reg[1] ) ;
††††*Gy = ( (short) (reg[2] << 8) + reg[3] ) ;
††††*Gz = ( (short) (reg[4] << 8) + reg[5] ) ;

††††††††
}

Void get_acc(short *Ax,short *Ay,short *Az)
{
Uint8 reg[6],status;

††††Reg[0] = hal_dev_mpu6050_read_reg(ACCEL_XOUT_H);
††††Reg[1] = hal_dev_mpu6050_read_reg(ACCEL_XOUT_L);

††††Reg[2] = hal_dev_mpu6050_read_reg(ACCEL_YOUT_H);
††††Reg[3] = hal_dev_mpu6050_read_reg(ACCEL_YOUT_L);

††††Reg[4] = hal_dev_mpu6050_read_reg(ACCEL_ZOUT_H);
††††Reg[5] = hal_dev_mpu6050_read_reg(ACCEL_ZOUT_L);

††††*Ax = ( (short) (reg[0] << 8) + reg[1] ) ;
††††*Ay = ( (short) (reg[2] << 8) + reg[3] ) ;
††††*Az = ( (short) (reg[4] << 8) + reg[5] ) ;
††††††††
}
